#### 程序的机器级表示

#### 数据格式

字节(8位）、字(16位)、双字(32位)、四字(64位)

| C声明 | Intel数据类型 | 汇编代码后缀 | 大小 |
| ----- | ------------- | ------------ | ---- |
|   char    |   字节            |   b           |   1   |
| short | 字 | w | 2 |
| int | 双字 | l | 4 |
| long | 四字 | q | 8 |
| char * | 四字 | q | 8 |
| float | 单精度 | s | 4 |
| double | 双精度 | l | 8 |

#### 访问信息

x86-64包含一组16个存储64位值的通用目的寄存器

#### 寻址模式

掌握11种寻址模式 P121

#### 数据传送指令

movb, movw, movl, movq, movabsq

movq指令将32位补码数字立即数作为源操作数，符号扩展至64位传送

movabsq以任意64位立即数值作为源操作数，且只能以寄存器为目的

##### 练习题3.4

#### 压入和弹出栈

栈指针寄存器%rsp保存栈顶元素地址

| 指令    | 效果                                    | 描述         |
| ------- | --------------------------------------- | ------------ |
| pushq S | R[%rsp] <- R[%esp] - 8, M[R[%rsp]] <- S | 将四字压栈   |
| popq D  | D <- M[R[%rsp]] R[%rsp] <- R[%rsp] + 8  | 将四字弹出栈 |

由汇编指令可知， 栈向低地址生长

压栈是减小rsp值，将数据存放。

出栈是内存中取数据，再增加rsp值

#### 算术和逻辑指令

lea 加载有效地址

```
lea 0xA(, %rax, 4), %rdx 	%rdx = %rax * 4 + 10
```

#### 移位操作

移位量可以是立即数，或单字节寄存器%cl

```C
salq $4 %rax
sarq %cl %rax
```

#### 条件码和跳转指令

掌握跳转指令编码规则， 地址计算

#### 条件传送指令

**为什么条件数据传送指令的性能比条件控制转移来的好？**

不是所有条件表达式均可用条件传送实现

```C
int fx(int *x) {
	return (x ? *x : 0);
}	// 副作用表达式，强制GCC用条件转移实现这个函数
```

#### 条件代码与跳转

最后的四个标识位（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，意思是：

- CF: Carry Flag (针对无符号数)
- ZF: Zero Flag
- SF: Sign Flag (针对有符号数)
- OF: Overflow Flag (针对有符号数)

可以看到以上这四个标识位，表示四种不同的状态，举个例子，假如我们有一条诸如 `t = a + b` 的语句，汇编之后假设用的是 `addq Src, Dest`，那么根据这个操作结果的不同，会相应设置上面提到的四个标识位，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：

- 如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置
- 如果 t 等于 0，那么 ZF 标识位会被设置
- 如果 t 小于 0，那么 SF 标识位会被设置
- 如果 2’s complement 溢出，那么 OF 标识位会被设置为 1（溢出的情况是 `(a>0 && b > 0 && t <0) || (a<0 && b<0 && t>=0)`）

这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 `leaq` 指令的话不会进行设置。

#### 掌握跳转表

switch的变量范围如何确定？判断default分支，正常分支，fall-through场景

#### 过程(重要)

##### 理解call, pop指令 书P166

假设过程P调用过程Q，Q执行后返回到P

* 传递控制	进入Q时，将PC设置为Q起始地址，返回时设为P调用Q后面那条指令的地址

* 传递数据     P必须能向Q传递一个或多个参数，Q必须向P返回一个值

* 分配和释放内存    开始时Q可能需要为局部变量分配空间，返回前又必须释放这些空间

##### 理解调用者保存寄存器和被调用保存寄存器

被调用者保存寄存器，rbx, rbp, r12~r15**意思是当过程P调用过程Q时，Q必须保存这些寄存器的值**-> 方法：要么不改变这些值，要么返回前从栈中弹出旧值

调用者保存寄存器: 除了rsp, rbx, rbp, r12-r15，意味着任何函数都能修改它们。理解：**过程P在某个被调用者保存寄存器有局部数据，然后调过程Q，因为Q可以随意修改这个寄存器，因此调用前保存这个数据是调用者P的责任**

<font color = 'red'>**掌握调用者保存寄存器和被调用保存寄存器的基础上理解递归过程**</font>

指令小结

Call指令： 将PC(%rip)压栈后跳转

Ret指令: 弹出栈，并跳转到这个地址

**可以通过push (addr)和ret指令组合，实现代码注入**

##### 数据传送规则

一个函数超过6个参数用栈传递，否则直接用寄存器传递(因为被调用者保存寄存器刚好只有6个)

#### 结构和联合

掌握结构体对齐，sizeof()计算

#### 缓冲区溢出

可能破坏未使用的栈空间、返回地址、甚至调用者保存的寄存器

##### 如何对抗？

* 栈随机化

* 栈保护， 思想是在局部缓冲区和栈状态之间存储一个canary

* 限制可执行代码区域


























































































