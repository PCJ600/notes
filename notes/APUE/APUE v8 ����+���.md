### 进程标识

ID为0的进程通常为调度进程，常称为交换进程。该进程是内核的一部分，不执行磁盘上的任何程序，因此称为系统交换进程

ID为1的通常是init进程，自举过程结束后由内核调用。init进程绝不会终止，是一个普通用户进程，却以超级用户权限运行。

#### fork

fork的一个特性是父进程所有文件描述符都被复制到子进程中

父进程很多属性由子进程继承，属性如下：

* 实际用户ID，实际组ID，有效用户ID，有效组ID
* 附属组ID
* 进程组ID

#### 僵尸进程

一个已经终止，但其父进程未对其进行善后处理的进程

对于父进程已经终止的所有进程，它们的父进程改为init进程。

#### wait和waitpid

当一个进程正常或异常终止时，内核向其父进程发送SIGCHLD信号。因为子进程终止是异步事件，所以这种信号也是内核向父进程发送的异步通知。

对SIGCHLD信号，系统默认忽略，调用wait和waitpid如下：

* 如果所有子进程都在运行，则阻塞
* 如一个子进程终止，正等待父进程获取终止状态，则取得该子进程终止状态立即返回
* 如没有任何子进程，立即出错返回

```C
#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
```

若成功返回进程ID，出错返回0或-1

若调用进程没有子进程，waitpid返回1，设置errno为ECHILD

如waitpid被信号中断，返回-1，设置errno为EINTR

##### 检查wait和waitpid所返回的终止状态的宏

| 宏                   | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| WIFEXITED(status)    | 正常终止子进程返回的状态，可执行WEXITSTATUS(status)，获取子进程传送给exit参数的低8位 |
| WIFSIGNALED(status)  | 异常终止子进程返回的状态，可执行WTERMSIG(status)，获取使子进程终止的信号编号。 |
| WIFSTOPPED(status)   | 当前暂停子进程返回的状态，可执行WSTOPSIG(status)，获取使子进程暂停的信号编号 |
| WIFCONTINUED(status) | 作业控制暂停后已经继续的子进程返回的状态                     |

waitpid函数返回终止子进程的进程ID，并将子进程终止状态存放在statloc指向的存储单元中

waitpid函数中pid参数的作用

```txt
pid == -1 	等待任一子进程，与wait等效
pid > 0 等待进程组ID与pid相等的子进程
pid == 0 等待组ID等于调用进程组ID的任一子进程
pid < -1 等待组ID等于pid绝对值的任一子进程
```

options参数可进一步控制waitpid操作，

| 常量       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| WCONTINUED | 由pid指定任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态 |
| WNOHANG    | 由pid指定的子进程并不是立即可用的，则waitpid不阻塞，返回值为0 |
| WUNTRACED  | 由pid指定的任一子进程已处于停止状态，且其状态自停止以来还未报告，则返回其状态 |



















































