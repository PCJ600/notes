## CSAPP 链接

#### 编译器驱动程序

* 预处理器 main.c -> main.i

* 编译器ccl main.i -> main.s
* 汇编器as  main.s -> main.o
* 链接器ld main.o -> main

```shell
gcc --help	# -E, -s, -c
```

#### 构造可执行程序，链接器必须完成：

* 符号解析 —— 将每个符号引用正好与一个符号定义关联

* 重定位 —— 编译器和汇编器生成从0地址开始的代码和数据节，链接器通过把每个符号定义与一个内存位置关联，从而重定位这些节

#### 目标文件类型

| 类型             | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| 可重定位目标文件 | 包含二进制代码和数据，可在编译时与其他可重定位目标文件合并，创建可执行目标文件 .o |
| 可执行目标文件   | 包含二进制数据和代码，可直接被复制到内存执行 .exe            |
| 共享目标文件     | 可在加载或运行时被动态加载进内存并链接 .so                   |

Linux x86-64可执行程序： Executeable and Linkable Format， 即ELF

##### 可重定位目标文件

| 条目  | 说明 |
| ----- | ---- |
| ELF头 | 16字节序列，描述字长、目标文件类型，节头部表等信息     |
| .text | 代码段     |
| .rodata | 只读数据，如printf中格式串和开关语句的跳转表     |
| .data | 已初始化全局和静态变量，     |
| .bss | 未初始化全局和静态变量，及所有初始化为0的全局或静态变量     |
| .symtab | 存放程序中定义和引用的全局变量和函数信息, 不包含局部变量符号。用strip命令去除符号     |
| .rel.text | 一个.text节中位置列表，当链接器把这目标文件和其他文件组合时需修改这些位置     |
| rel.data | 被模块引用或定义的所有全局变量重定位信|
| .debug | 调试符号表，包括程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，原始的C源文件，以-g参数编译才有这张表 |
| .strtab | 字符串表，内容包括.symtab和.debug中符号表，以及节头部中的节名字 |

**TIPS:**

* ELF文件格式: readelf -h 查看
* bss段作用仅是一个占位符，区分已初始化和未初始化为了提高效空间效率
* 局部变量位于栈中，不属于.data或.bss节

例子

```C
int f() {
	static int x = 0;
	return x;
}
int g() {
	static int x = 0;
	return x;
}
```

编译器向汇编器输出两个不同名字的局部链接器符号，可用x.数字的形式区分(readelf -s可查看)

##### ELF文件伪节

| 伪节名 | 说明                                       |
| ------ | ------------------------------------------ |
| ABS    | 不该被重定义的符号                         |
| UNDEF  | 未定义符号，本模块引用，其他地方定义的符号 |
| COMMON | 与bss区别： COMMON分配未初始化的全局变量   |

#### 符号解析

将每个引用与它输入的可重定位目标文件的符号表中一个确定的符号定义关联

##### 链接器如何解析多重定义的全局符号

编译时，编译器向汇编器输出每个全局符号。函数和已初始化全局变量是强符号，未初始化的全局变量是弱符号

**Linux链接器使用下列规则处理多重符号的符号名：**

* 不允许有多个同名的强符号
* 如有一个强符号和一个多个弱符号同名，选择强符号
* 如有多个弱符号，从弱符号中任意选择一个

gcc的fno-common选项，告诉链接器遇到多重定义的全局符号时，触发一个错误









































