#### 程序的机器级表示

#### 数据格式

字节(8位）、字(16位)、双字(32位)、四字(64位)

| C声明 | Intel数据类型 | 汇编代码后缀 | 大小 |
| ----- | ------------- | ------------ | ---- |
|   char    |   字节            |   b           |   1   |
| short | 字 | w | 2 |
| int | 双字 | l | 4 |
| long | 四字 | q | 8 |
| char * | 四字 | q | 8 |
| float | 单精度 | s | 4 |
| double | 双精度 | l | 8 |

#### 访问信息

x86-64包含一组16个存储64位值的通用目的寄存器

#### 寻址模式

掌握11种寻址模式 P121

#### 数据传送指令

movb, movw, movl, movq, movabsq

movq指令将32位补码数字立即数作为源操作数，符号扩展至64位传送

movabsq以任意64位立即数值作为源操作数，且只能以寄存器为目的

##### 练习题3.4

#### 压入和弹出栈

栈指针寄存器%rsp保存栈顶元素地址

| 指令    | 效果                                    | 描述         |
| ------- | --------------------------------------- | ------------ |
| pushq S | R[%rsp] <- R[%esp] - 8, M[R[%rsp]] <- S | 将四字压栈   |
| popq D  | D <- M[R[%rsp]] R[%rsp] <- R[%rsp] + 8  | 将四字弹出栈 |

由汇编指令可知， 栈向低地址生长

压栈是减小rsp值，将数据存放。

出栈是内存中取数据，再增加rsp值

#### 算术和逻辑指令

lea 加载有效地址

```
lea 0xA(, %rax, 4), %rdx 	%rdx = %rax * 4 + 10
```

#### 移位操作

移位量可以是立即数，或单字节寄存器%cl

```C
salq $4 %rax
sarq %cl %rax
```

#### 条件码和跳转指令

掌握跳转指令编码规则， 地址计算

#### 条件传送指令

为什么条件数据传送指令的性能比条件控制转移来的好？

不是所有条件表达式均可用条件传送实现

```C
int fx(int *x) {
	return (x ? *x : 0);
}	// 副作用表达式，强制GCC用条件转移实现这个函数
```

#### 掌握跳转表

switch的变量范围如何确定？判断default分支，正常分支，fall-through场景

#### 过程(重要)

##### 理解call, pop指令 书P166

假设过程P调用过程Q，Q执行后返回到P

* 传递控制	进入Q时，将PC设置为Q起始地址，返回时设为P调用Q后面那条指令的地址

* 传递数据     P必须能向Q传递一个或多个参数，Q必须向P返回一个值

* 分配和释放内存    开始时Q可能需要为局部变量分配空间，返回前又必须释放这些空间

##### 理解调用者保存寄存器和被调用保存寄存器

被调用者保存寄存器，rbx, rbp, r12~r15**意思是当过程P调用过程Q时，Q必须保存这些寄存器的值**-> 方法：要么不改变这些值，要么返回前从栈中弹出旧值

调用者保存寄存器: 除了rsp, rbx, rbp, r12-r15，意味着任何函数都能修改它们。理解：**过程P在某个被调用者保存寄存器有局部数据，然后调过程Q，因为Q可以随意修改这个寄存器，因此调用前保存这个数据是调用者P的责任**

<font color = 'red'>**掌握调用者保存寄存器和被调用保存寄存器的基础上理解递归过程**</font>

##### 数据传送规则

一个函数超过6个参数用栈传递，否则直接用寄存器传递(因为被调用者保存寄存器刚好只有6个)

#### 结构和联合

掌握结构体对齐，sizeof()计算

#### 缓冲区溢出

可能破坏未使用的栈空间、返回地址、甚至调用者保存的寄存器

##### 如何对抗？

栈随机化

栈保护， 思想是在局部缓冲区和栈状态之间存储一个canary

限制可执行代码区域


























































































