## CSAPP c7 链接

#### 编译器驱动程序

* 预处理器 main.c -> main.i

* 编译器ccl main.i -> main.s
* 汇编器as  main.s -> main.o
* 链接器ld main.o -> main

```shell
gcc --help	# -E, -s, -c
```

### 构造可执行程序，链接器必须完成两件事

* 符号解析 —— 将每个符号引用正好与一个符号定义关联

* 重定位 —— 编译器和汇编器生成从0地址开始的代码和数据节，链接器通过把每个符号定义与一个内存位置关联，从而重定位这些节

### 目标文件类型

| 类型             | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| 可重定位目标文件 | 包含二进制代码和数据，可在编译时与其他可重定位目标文件合并，创建可执行目标文件 .o |
| 可执行目标文件   | 包含二进制数据和代码，可直接被复制到内存执行 .exe            |
| 共享目标文件     | 可在加载或运行时被动态加载进内存并链接 .so                   |

Linux x86-64可执行程序： Executeable and Linkable Format， 即ELF

### 可重定位目标文件

| 条目  | 说明 |
| ----- | ---- |
| ELF头 | 16字节序列，描述字长、目标文件类型，节头部表等信息     |
| .text | 代码段     |
| .rodata | 只读数据，如printf中格式串和开关语句的跳转表     |
| .data | 已初始化全局和静态变量，     |
| .bss | 未初始化全局和静态变量，及所有初始化为0的全局或静态变量     |
| .symtab | 存放程序中定义和引用的全局变量和函数信息, 不包含局部变量符号。用strip命令去除符号     |
| .rel.text | 一个.text节中位置列表，当链接器把这目标文件和其他文件组合时需修改这些位置     |
| rel.data | 被模块引用或定义的所有全局变量重定位信|
| .debug | 调试符号表，包括程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，原始的C源文件，以-g参数编译才有这张表 |
| .strtab | 字符串表，内容包括.symtab和.debug中符号表，以及节头部中的节名字 |

**TIPS:**

* ELF文件格式: readelf -h 查看
* bss段作用仅是一个占位符，区分已初始化和未初始化为了提高效空间效率
* 局部变量位于栈中，不属于.data或.bss节

例子

```C
int f() {
	static int x = 0;
	return x;
}
int g() {
	static int x = 0;
	return x;
}
```

编译器向汇编器输出两个不同名字的局部链接器符号，可用x.数字的形式区分(readelf -s可查看)

### 符号和符号表

#### ELF文件伪节

| 伪节名 | 说明                                       |
| ------ | ------------------------------------------ |
| ABS    | 不该被重定义的符号                         |
| UNDEF  | 未定义符号，本模块引用，其他地方定义的符号 |
| COMMON | 与bss区别： COMMON分配未初始化的全局变量   |

### 符号解析

将每个引用与它输入的可重定位目标文件的符号表中一个确定的符号定义关联

#### 链接器如何解析多重定义的全局符号

编译时，编译器向汇编器输出每个全局符号。函数和已初始化全局变量是强符号，未初始化的全局变量是弱符号

**Linux链接器使用下列规则处理多重符号的符号名：**

* 不允许有多个同名的强符号
* 如有一个强符号和一个多个弱符号同名，选择强符号
* 如有多个弱符号，从弱符号中任意选择一个

gcc的fno-common选项，告诉链接器遇到多重定义的全局符号时，触发一个错误

#### 静态链接

以一种成为存档(archive)文件格式存放，存储一组连接起来的可重定位目标文件的集合，由后缀.a标识

```shell
gcc -c addvec.c mulvec.c
ar rcs libvector.a addvec.o mulvec.o
```

##### 链接器如何解析多重定义的全局符号

链接器维护一个可重定位目标文件的集合E，一个未解析符号合集U，一个在前面输入文件中已定义的符号集合D, 初始U, E, D均为空

* 对于命令行上每个输入文件f, 链接器判断f是一个目标文件还是存档文件。如果f是目标文件，链接器将f添加到E，修改U，D反映f中的符号定义和引用，继续下一个输入文件
* 如f是一个存档文件，链接器尝试匹配U中未解析符号和由存档文件定义的符号。如果某个存档文件成员m, 定义了一个符号解析U中一个引用，就将m加入E， 并且链接器通过修改U和D来反映m中的符号引用。对存档文件中所有的目标文件都依次进行这个过程，直到U和D不再发生变化。**此时不在E中的成员目标文件被简单丢弃，链接器继续处理下一个输入文件。**

* 如果链接器完成对命令行上输入文件扫描之后，U是非空的，链接器就会输出一个错误并终止。否则会合并和重定位E上的目标文件，输出可执行文件

##### 使用静态库解析引用带来的问题

必须注意命令行上的库和目标文件的链接顺序。如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接失败

```shell
gcc -static ./libvec.a main.c			#顺序错误， 需要将.a放在结尾
```

一般准则是将.a放在命令行结尾，**如果库不是相互独立的，必须排序，使得对于每个存档文件的成员外部引用的符号s, 在命令行中至少有一个s定义是在对s的引用之后**

### 重定位

重定位由两步组成：

* 重定位节和和符号定义， 链接器将所有的节合并为同一类型的聚合节，然后将运行时内存地址赋给新的聚合节，这步完成后，程序中的每条指令和全局变量都有唯一的内存地址

* 重定位节中的符号引用， 链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。这一步依赖可重定位目标模块中称为重定位条目的数据结构

#### 重定位条目

汇编器遇到对最终位置未知的目标引用，会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用，重定位条目放在.rel.text, 已初始化数据的重定位条目放在.rel.data。ELF重定位条目格式如下：

```C
typedef struct {
	long offset;		// 需要被修改的引用的节偏移
	long type:32;		// 告知链接器如何修改新的引用 
		 symbol:32;		// 标识被修改引用应该指向的符号
	long addend;		// 有符号常数，一些类型的重定位靠它对被修改引用值做偏移调整，比如call指令
} Elf64_Rela;
```

ELF定义了32中重定位类型，需关心最重要的两种

* R_X86_64_PC32。重定位一个使用32位PC相对地址的引用。当CPU执行到一条使用PC相对寻址的指令，它就将在指令中编码的32位值加上PC的当前运行值，得到有效地址，PC值通常为下一条指令在内存中的地址
* R_X86_64_32 重定位一个使用32位PC绝对地址的引用。通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需进一步修改

#### 举例

```
od -dx main.o
Disassembly of section .text:
0000000000000000 <main>:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   48 83 ec 10             sub    $0x10,%rsp
   8:   be 02 00 00 00          mov    $0x2,%esi
   d:   bf 00 00 00 00          mov    $0x0,%edi
                        e: R_X86_64_32  array				#绝对地址引用
  12:   e8 00 00 00 00          callq  17 <main+0x17>
                        13: R_X86_64_PC32       sum-0x4		#相对地址引用，用四字节0的占位符
  17:   89 45 fc                mov    %eax,-0x4(%rbp)
  1a:   8b 45 fc                mov    -0x4(%rbp),%eax
  1d:   c9                      leaveq
  1e:   c3                      retq
  
  000000000060102c g     O .data  0000000000000008              array
  00000000004004ed <main>:
  4004ed:   55                      push   %rbp
  4004ee:   48 89 e5                mov    %rsp,%rbp
  4004f1:   48 83 ec 10             sub    $0x10,%rsp
  4004f5:   be 02 00 00 00          mov    $0x2,%esi
  4004fa:   bf 2c 10 60 00          mov    $0x60102c,%edi
  4004ff:   e8 08 00 00 00          callq  40050c <sum>
  400504:   89 45 fc                mov    %eax,-0x4(%rbp)
  400507:   8b 45 fc                mov    -0x4(%rbp),%eax
  40050a:   c9                      leaveq
  40050b:   c3                      retq
```

对于sum使用相对地址，offset偏移位0x400500 - 4004ed = 0x12 , sum绝对地址0x40050c, main绝对地址0x4004ed, call指令应填充 40050c - 400504 = 0x8

对于array使用绝对地址，直接将array地址0x60102c传给edi即可

### 可执行目标文件

格式类似于可重定位目标文件，包括程序的入口点，即程序运行时执行的第一条指令的地址

有init节，定义了一个小函数，_init，程序初始化代码会调用它

可执行文件是完全链接的，所以不需要rel节

### 加载可执行目标文件

加载器将可执行目标文件中的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一个指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫加载

#### Linux x86-64运行时内存映像

内核内存

用户栈(向低地址增长)

共享库的内存映射区域

运行时堆(向高地址增长)

读写段(.data, .bss)

只读代码段(.init, .text, .rodata)

### 动态链接库

对于一个库只有一个so文件，所有引用该库的可执行目标文件共享这个so的代码和数据

其次，内存中一个共享库的.text一个副本可以被不同的正在运行的进程共享

#### Linux为动态链接器提供的一些接口

```C
#include <dlfcn.h>
void *dlopen(const char *filename, int flag); // 加载共享库filename, flag取值为RTLD_LAZY, RTLD_NOW, RTLD_GLOBAL
void *dlsym(void *handle, char *symbol);	  // 返回：若成功为指向符号的指针，若出错则为NULL
int dlclose(void *handle);					  // 如果没有其它共享库使用这个共享库，dlclose函数就卸载该共享库
```

#### 什么是地址无关代码

可以加载而无需重定位的代码称为位置无关代码。(Position Independent Code PIC)

对同一个目标模块中符号引用无需特殊处理，采用PC相对寻址编译这些引用

#### PIC数据引用

原理：无论我们在内存中何处加载一个目标模块，数据段和代码段距离总保持不变，这与代码段和数据段的绝对位置无关

在数据段开始地方创建一个表，叫**全局偏移量表(Global Offset Table, GOT)**, GOT中每个被这个目标模块引用的全局数据目标都有一个8字节条目，加载时动态链接器会重定位GOT中每个条目，使得它包含目标的正确的绝对地址。

举例:

下图为libvector.so的GOT表，addvec通过GOT[1]间接加载全局变量addcnt的地址，关键是对GOT[1]的PC相对引用中的偏移量是一个运行时常量

```tex
数据段 GOT表
GOT[0]: ...
GOT[1]: &addcnt	#运行时GOT[1]和addl指令之间距离固定是0x2008b9
代码段
addvec:
	mov 0x2008b9(%rip), %rax
	add $0x1, (%rax)			
```

#### PIC函数调用

延迟绑定技术

过程链接表(PLT)和全局偏移量表(GOT) 《CSAPP 3th》P491

#### 库打桩机制

* 编译时打桩
* 链接时打桩
* 运行时打桩

### 处理目标文件的工具

strings, strip, nm, readelf, objdump, ldd, ar, size等等































