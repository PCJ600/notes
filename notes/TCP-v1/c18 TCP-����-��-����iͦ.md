## c18 TCP连接的建立与终止

#### 三次握手(连接建立)

请求端发送一个SYN指明客户端打算连接的服务器端口，和初始序号

服务器发回包含服务器初始序号的SYN报文段作为应答，同时将确认序号设置为客户的ISN+1,对客户的SYN报文段确认

客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认

这三个报文段完成连接的建立，过程被成为三次握手

主动打开：发送SYN的一端执行主动打开

被动打开：接收这个SYN并发回下一个SYN另一端执行被动打开

如何选择ISN?, 32位比特计数器,每4ms加1, **防止网络中被延迟的分组在以后又被传送?**



#### 四次挥手(连接中止)

TCP连接是全双工的,因此每个方向必须单独的进行关闭

收到一个FIN只意味着这个方向没有数据流动,一个TCP连接在收到一个FIN后仍能发送数据

首先进行关闭的一方执行主动关闭, 另一方执行被动关闭

过程:

TCP客户端发送一个FIN,关闭客户从服务器的数据传送

服务器收到这个FIN,它返回一个ACK,确认序号为收到序号加1, 一个FIN将占用一个序号.同时TCP服务器还向应用程序传送一个文件结束符

接着服务器关闭连接,导致发送一个FIN

客户必须发回一个确认,并将确认序号设置为收到序号加1

#### 简单回射程序(非迭代非并发)抓包

```shell
服务端 192.168.0.100 端口9877
客户端 192.168.0.105 临时端口
三次握手
09:18:37.316083 IP 192.168.0.105.57962 > 192.168.0.100.9877: Flags [S], seq 589530732, win 29200, options [mss 1460,sackOK,TS val 383644 ecr 0,nop,wscale 7], length 0
09:18:37.316111 IP 192.168.0.100.9877 > 192.168.0.105.57962: Flags [S.], seq 2376443707, ack 589530733, win 28960, options [mss 1460,sackOK,TS val 383292 ecr 383644,nop,wscale 7], length 0
09:18:37.317085 IP 192.168.0.105.57962 > 192.168.0.100.9877: Flags [.], ack 2376443708, win 229, options [nop,nop,TS val 383645 ecr 383292], length 0
客户端输出helloJava,服务端接收并回射，客户端回显到终端
09:19:54.498279 IP 192.168.0.105.57962 > 192.168.0.100.9877: Flags [P.], seq 589530733:589530743, ack 2376443708, win 229, options [nop,nop,TS val 402940 ecr 383292], length 10
09:19:54.498836 IP 192.168.0.100.9877 > 192.168.0.105.57962: Flags [.], ack 589530743, win 227, options [nop,nop,TS val 402588 ecr 402940], length 0
09:19:54.499296 IP 192.168.0.100.9877 > 192.168.0.105.57962: Flags [P.], seq 2376443708:2376443718, ack 589530743, win 227, options [nop,nop,TS val 402588 ecr 402940], length 10
09:19:54.500593 IP 192.168.0.105.57962 > 192.168.0.100.9877: Flags [.], ack 2376443718, win 229, options [nop,nop,TS val 402940 ecr 402588], length 0
四次挥手
09:21:09.244375 IP 192.168.0.105.57962 > 192.168.0.100.9877: Flags [F.], seq 589530743, ack 2376443718, win 229, options [nop,nop,TS val 421626 ecr 402588], length 0
09:21:09.244603 IP 192.168.0.100.9877 > 192.168.0.105.57962: Flags [F.], seq 2376443718, ack 589530744, win 227, options [nop,nop,TS val 421275 ecr 421626], length 0
09:21:09.245937 IP 192.168.0.105.57962 > 192.168.0.100.9877: Flags [.], ack 2376443719, win 229, options [nop,nop,TS val 421626 ecr 421275], length 0
```

#### 先关读, 后关写 以客户机发起关闭连接为例

服务器读通道关闭

客户机写通道关闭

客户机读通道关闭

服务器写通道关闭

#### tcpdump输出

默认情况tcpdump只在显示SYN报文段时显示完整序号,对其后的序号显示它们与初始序号的相对偏移值(-S)

#### 连接建立的超时 (抓包)

关闭telnet服务端，用客户端尝试连接

关闭telnet服务

#### 最大报文段长度(MSS)

表示TCP传往另一端的最大块数据的长度。

MSS选项只能出现在SYN报文段，如一方不接收来自另一方的MSS，默认为536字节(允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报)

如目的IP地址为非本地的， MSS通常默认536，区分本地和非本地

如果目的IP地址的网络号与子网号都和我们的相同，则是本地的。

如果目的IP地址的网络号与我们的万群不同，则可能是本地的，可能是非本地的

#### TCP的半关闭

TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是半关闭

如应用程序不调用close而调用shutdown，且第2个参数为1， 则socket的API支持半关闭

#### 为什么要有半关闭？

客户端已完成它的数据传送，但仍要接收来自服务端的数据

#### TCP状态变迁图

![image-20200405143852357](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20200405143852357.png)

ESTABLISHED状态是连接双方能够进行双向问数据传递的状态

#### TIME_WAIT状态（两MSL等待状态）

MSL： Maximum Segment Lifetime(典型时间30s, 1min, 2min)

**IP数据报TTL的限制基于跳数，不是定时器？**

每个具体TCP实现必须选择一个报文段最大生存时间(MSL), 是任何报文段被丢弃前在网络内的最长时间

原则：当TCP执行一个**主动关闭**,并返回最后一个ACK, 该连接必须在TIME_WAIT状态停留时间为2MSL。这样T可让TCP再次发送最后的ACK以防这个ACK丢失()

#### 为什么TIME_WAIT状态需要2MSL(UNP v1)

lost duplicate

可靠地实现TCP全双工连接的终止

允许老的重复分节在网路中消逝

* 为保证A发送的最后一个ACK报文段能够达到B。最后这个ACK报文段有可能丢失，B就会超时重传，然后再一次确认，启动2MSL计时器。如果不等待，A发送完ACK后立即释放连接，B无法重传，也收不到A的确认，就无法按四次挥手的步骤进入CLOSED状态(即无法实现必须收到确认才能CLOSE)

TCP连接在2MSL等待期间，定义这个连接的socket不能被使用，只能在2MSL结束后才能再被使用。大多数TCP实现更加严格，2MSL期间，socket中使用的本地端口默认不能被使用(SO_REUSRADDR套接字选项可避开此限制)

一个socket对在处于2MSL等待时，不能被使用。尽管许多具体实现允许一个进程重用2MSL等待的端口，但TCP不允许一个新连接建立在相同的socket对

#### 服务器主动关闭，再次打开显示bind error原因？

#### 平静时间

TCP在重启动后的MSL内不能建立任何连接

**FIN_WAIT_2状态**

- **收到对端的FIN之前，本端会一直保持FINWAIT-2状态**(标准的要求)
- **收到对端的FIN之前，本端会保持FINWAIT-2状态一段足够的时间，超过此时间，连接即释放**(现实的要求)

实现违背协议规范！

#### 到不存在的端口的连接请求(抓包)

当一个数据报到达目的端口时，该端口没在使用，TCP将使用复位RST

```shell
$ root@ubuntu1:/data# telnet 192.168.0.101
Trying 192.168.0.101...
telnet: Unable to connect to remote host: Connection refused
// 报文
08:52:23.596919 IP 192.168.0.105.56490 > 192.168.0.101.telnet: Flags [S], seq 499186042, win 29200, options [mss 1460,sackOK,TS val 4294957914 ecr 0,nop,wscale 7], length 0
08:52:23.856350 IP 192.168.0.101.telnet > 192.168.0.105.56490: Flags [R.], seq 0, ack 499186043, win 0, length 0
```

#### 异常终止一个连接

#### 检测半打开连接

如一方已经关闭或异常终止连接而另一方不知道，将这样的TCP连接称为半打开(Half-Open)。

半打开连接的常见原因是客户主机突然掉电而不是正常结束客户应用程序再关机。

#### 同时打开

TCP特意设计为了可以处理同时打开，对于同时打开仅建立一条连接而不是两条

![image-20200406095033960](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20200406095033960.png)

一个同时打开的连接需要交换4个报文段，比正常的三次握手多一个。每一端既是客户又是服务器

#### 同时关闭

![image-20200406095847544](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20200406095847544.png)



























































































































































































